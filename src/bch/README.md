Декодирование БЧХ-кодов

Так мини бабка дала в штангу, то перед запуском проги нужно расписать некоторое количество теории. В принципе почти всё можно скопировать из моего отчета, вот основные моменты:
1. Вычисляем m -> n = 2^m - 1
2. Расписываем задание порождающего многочлена как умножение минимальных (мини бабка дала многочлены в 8ричном формате, нужно просто перевести в 2чный и умножить многочлены)
3. Проверяем что степень g(x) совпадает c n-k
4. Расписываем множество корней g(x) - как это делать можете увидеть в моем отчете, но тут тоже распишу:
Берем наши корни и для каждого расписываем m значений (дальше они всё равно будут повторяться)
Например, для a^3: v^3, v^6, v^12 (тупо умножаем на 2 начальную степень)
Но нужно помнить что у нас всё по mod n, поэтому если степень v больше этого числа, то просто вычитаем из нее n.
5. Находим из получшивегося множества максимальное количество подряд идущих элементов. 
d >= число подряд + 1
t = [(d - 1) / 2] - округляем вниз
6. Дальше теорию можно скопировать у меня, можно как-то переформулировать или самому скопировать из методички, прикрепленной к лабе, закинув в дипсик с просьбой отрефакторить.
7. Последним этапом будет рисование блок-схем, Mermaid-код добавлю в конце (онлайн редакторы и дипсик рисуют блок-схемы по этому коду)

Запуск программы
Заходим в run_bch.py и вводим n, k, m, t. Запускаем командой python -u "./src/main.py" и радуемся жизни.
Если хотите увидеть многочлен синдромов, то в файле в bch_decoder.py нужно расскоментировать 30 строчку: # print(f'Вычисленные синдромы: {syndromes}')

P. S.
Я так и не понял зачем нужен g(x), если мы только кодируем. Множество корней его многочлена нужно только для более простого вычисления синдромов и вычисления t, но это нахуй не надо в целом. t можно взять из книги, а не проводить долбоебское вычисление на страницу, а синдромы и так можно посчитать зная степени.

Также декодер может исправлять количество ошибок меньше, чем t. Если введете наоборот больше ошибок, чем t, то он ничего не исправит, и решит, что пользователь еблан.

Все комментарии в коде написал господин дипсик.


Б-М:
flowchart TD
    Start[Начало алгоритма Б-М] --> Init[Инициализация:<br/>Λ(x)=1, B(x)=1, L=0, m=1, b=1]
    Init --> Loop[Цикл r=0..9<br/>10 синдромов]
    Loop --> Compute[Вычисление невязки Δ<br/>Δ = S[r] + Σ Λ[i]*S[r-i]]
    Compute --> Check{Δ = 0?}
    Check -- Да --> IncM[m = m + 1]
    Check -- Нет --> Update[Обновление Λ(x):<br/>Λ_new = Λ - (Δ/b)*x^m*B]
    Update --> Condition{2L ≤ r?}
    Condition -- Нет --> IncM2[m = m + 1]
    Condition -- Да --> UpdateVars[L = r+1-L<br/>B = Λ_old<br/>b = Δ<br/>m = 1]
    IncM --> Next[Следующая итерация]
    IncM2 --> Next
    UpdateVars --> Next
    Next --> LoopEnd{Все 10 итераций?}
    LoopEnd -- Нет --> Loop
    LoopEnd -- Да --> Return[Возврат Λ(x)]

Синдромы:
graph TD
    Start[Начало вычисления синдромов] --> Init[Инициализация:<br/>syndromes = пустой список<br/>j = 1]
    
    Init --> Loop1[Цикл по j от 1 до 2t]
    Loop1 --> InitS[Инициализация:<br/>syndrome = 0<br/>alpha_power = 1]
    
    InitS --> Loop2[Цикл по i от 0 до n-1]
    
    Loop2 --> CheckBit{Принятый бит b[i] = 1?}
    CheckBit -->|Да| Add[Добавить к синдрому:<br/>syndrome = syndrome ⊕ alpha_power]
    CheckBit -->|Нет| Skip[Пропустить]
    
    Add --> UpdatePower[Обновить степень:<br/>alpha_power = alpha_power × αʲ<br/>в поле GF(2^m)]
    Skip --> UpdatePower
    
    UpdatePower --> NextBit{i < n-1?}
    NextBit -->|Да| Loop2
    NextBit -->|Нет| StoreS[Сохранить синдром:<br/>syndromes[j-1] = syndrome]
    
    StoreS --> NextJ{j < 2t?}
    NextJ -->|Да| Loop1
    NextJ -->|Нет| Return[Возврат syndromes]
    
    style Start fill:#e6f3ff
    style Return fill:#e6ffe6
    style Loop1 fill:#fff0f5
    style Loop2 fill:#f0fff0

main:
graph TD
    Start[Начало] --> Init[Инициализация: n=31,k=10,t=5]
    Init --> Input[Вход: 31 бит]
    Input --> CheckLen{Длина=31?}
    CheckLen -->|Нет| Error1[Ошибка длины]
    CheckLen -->|Да| Syndromes[Синдромы S1..S10]
    Syndromes --> CheckSyn{Все S=0?}
    CheckSyn -->|Да| NoErrors[Нет ошибок]
    CheckSyn -->|Нет| BM[Алгоритм Берлекэмпа-Месси]
    BM --> Chien[Метод Ченя]
    Chien --> CheckNum{Ошибок ≤5?}
    CheckNum -->|Нет| Error2[Слишком много ошибок]
    CheckNum -->|Да| Correct[Исправление]
    Correct --> Result[Результат]
    NoErrors --> Result
    Error1 --> End
    Error2 --> End
    Result --> End[Конец]

